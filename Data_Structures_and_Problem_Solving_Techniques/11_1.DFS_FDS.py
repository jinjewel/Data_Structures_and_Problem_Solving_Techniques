#######################################
# 정보통계학과 
# 학번 : 2019015020 
# 이름 : 오진석
# 작성일 : 11.23
#######################################

## 오릴러 문제(1800년대)
# 다리를 한번만 건너서 처음 출발했던 장소로 돌아오는 문제
# 위치 : 정점(노드), 다리 : 간선
# 모든 정점에 연결된 간선의 수가 짝수이면 오일러 경로 존재함
# 따라서 그래프(b)에는 오일러 경로가 존재하지 않음

## 그래프란
# 연결되어 있는 객체간의 관계를 표현하는 자료구조
# 가장 일반적인 자료구조 형태
# 그래프 G는 (V, E)로 표시
# 정점 또는 노드
# 간선 또는 링크 : 정점들 간의 관계 의미
# 시각 적으로 달라도, 모든 정점사이의 관계가 동일하면 같은 그래프로 판단

## 그래프의 용어
# 인접 정점 : 간선에 의해 직접 연결된 정점
# 차수 : 정점에 연결된 간선의 수
#    무방향 그래프의 차수의 합은 간선 수의 2배
#    방향 그래프에서 진입차수, 진출차수가 있고, 모든 진입(진출) 차수의 합은 간선의 수
# 그래프의 경로
#    무방향 그래프의 정점s로부터 정점e까지의 경로, 정점 : s,v1,v2,vk,e / 간선 (s, v1), (v1, v2) 등 존재
#    뱡향 그래프의 정점s로부터 정점e까지의 경로,  정점 : s,v1,v2,vk,e / 간선 <s, v1>, <v1, v2> 등 존재
# 경로의 길이 : 경로를 구성하는데 사용된 간선의 수
# 단순경로 : 경로중에 반복되는 간선이 없는 경로, 왔던 노드로 다시 돌아가지 않는 경로
# 사이클 : 시작 정점과 종료 정점이 동일한 경로
# 연결그래프 : 모든 정점들 사이에 경로가 존재하는 그래프
# 트리 : 사이클을 가지지 않는 연결 그래프, 사이클을 가지지 않는다.
# 완전 그래프 : 모든 정점 간의 간선이 존재하는 그래프,
#    n개의 정점을 가진 무방향 완전그래프의 간선의 수 = n*(n-1)/2

# 간선의 종류에 따라 분류되는 그래프 종류
## 무방향 그래프, 방향 존재 하지 않는다
# (A, B) = (B, A)
# V(G1) = {A, B, C, D}
# E(G1) = {(A, B), (A,C), (A,D), (B,C), (C,D)}

## 방향그래프 : 방향 존재
# <A,B> != <B,A>
# V(G3) = {A, B, C}
# E(G3) = {<A, B, C>, <B,A>, <B,C>} 

## 가중치 그래프, 네트워크
# 간선에 비용이나 가중치가 할당된 그래프

## 부분 그래프

## 그래프의 추상자료형(ADT)
# isEmpty() : 그래프가 공백 상태인지 확인한다.
# countVertex() : 정점의 수를 반환한다.
# countEdge() : 간선의 수를 반환한다.
# getEdge(u,v) : 정점 u에서 정점 v로 연결된 간선을 반환한다.
# degree(v) : 정점 v의 차수를 반환한다.
# adjacent : 정점 v에 인접한 모든 정점의 집합을 반환한다.
# insertVertex(v) : 그래프에 정점 v를 삽입한다.
# insertEdge(u, v) : 그래프에 간선(u, v)를 삽입한다.
# deleteVertex(v) : 그래프의 정점 v를 삭제한다.
# deleteEdge(u, v) : 그래프의 간선 (u, v)를 삭제한다.

## 인접행렬을 이용한 그래프의 표현
# 2차 정사각배열을 이용하여 값이 1이면 연결, 0이면 연결되지 않음을 표현
# 무방향 그래프는 인접행렬이 대칭이다.

## 인접 리스트를 이용한 표현
# 무방향 그래프 : 각 노드에 연결리스트로 표현
# 방향 그래프 : 각 노드에 연결리스트로 표현, 반복되기 전까지 각 노드에 연결

## 인접 행렬과 인접 리스트의 복잡도 비교

#########################


## 파이썬을 이용한 인접 행렬 표현
# 무방향 그래프

########################

# 가중치 그래프

########################

# 인접 정점 인덱스의 리스트

########################

# 파이썬의 딕셔너리와 인접 정점 집합이용

########################

## 그래프의 탐색
# 가장 기본적인 연산으로 시작 정점부터 차례대로 모든 정점들을 한 번씩 방문
# 많은 문제들이 단순히 탐색만으로 해결됨
# 방법으로 깊이 우선 탐색과 너비 우선 탐색이 있다.

## 깊이 우선 탐색
# DFS (depth first search)
# 한 방향으로 끝까지 가다가 더 이상 갈 수 없게 되면 가장 가가운 갈림 길로 돌아와서 다른 방향으로 다시 탐색 진행
# 되돌아 가기 위해서 스택이 필요
# 순환함수 호출로 묵시적인 스택 이용

## 너비 우선 탐색
# 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회방법
# 큐를 사용하여 구현됨

## 탐색 알고리즘 성능
# 깊이 우선 탐색 / 너비 우선 탐색
# 인접 행렬 표현 : O(n^2)
# 인접 리스트로 표현 : O(n + e)

# 완전그래프와 같은 조밀 그래프 -> 인접 행렬이 유리
# 희소 그래프 -> 인접 리스트가 유리

import collections
# 깊이 우선 탐색
def dfs(graph, start, visited = set()): # 처음 호출할때 visited 공집합
    if start not in visited: # start가 방문하지 않은 정점이면
        visited.add(start) # start를 방문한 노드 집합에 추가
        print(start, end=' ') # start를 방문했다고 출력함
        nbr = graph[start] - visited # {인접정점 중에 가보지 않은 정점} = {인접정점} - {방문정점}
        for v in nbr: 
            dfs(graph, v, visited) # v에 대해 dfs를 순환적으로 호출

# 너비 우선 탐색
def bfs(graph, start): 
    visited = set([start]) # 맨 처음에는 start만 방문한 정점임
    queue = collections.deque([start]) # 컬렉션의 덱 객체 생성(큐로 사용)
    while queue: # 공백이 아닐 때 까지
        vertex = queue.popleft() # 큐에서 하나의 정점 vertex를 빼냄
        print(vertex, end=' ') # vertex는 방문했음을 출력
        nbr = graph[vertex] - visited # {인접정점 중에 가보지 않은 정점} = {인접정점} - {방문정점} 
        for v in nbr:
            visited.add(v) # 이제 v는 방문했음
            queue.append(v) # v를 큐에 삽입

if __name__ == "__main__":
    
    graph = { 'A' : set(['B','C']),
             'B' : set(['A','D']),
             'C' : set(['A','D','E']),
             'D' : set(['B','C', 'F']),
             'E' : set(['C','G','H']),
             'F' : set(['D']),
             'G' : set(['E','H']),
             'H' : set(['E','G']) }
    
    dfs(graph, 'A')
    print("\n")
    bfs(graph, 'A')

# 출력
# A B D F C E H G 
#
# A B C D E F H G 


































