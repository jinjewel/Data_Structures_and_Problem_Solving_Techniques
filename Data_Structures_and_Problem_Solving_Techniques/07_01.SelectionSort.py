#######################################
# 정보통계학과 
# 학번 : 2019015020 
# 이름 : 오진석
# 작성일 : 10.26
#######################################

# 정렬이란 데이터를 순서대로 재배열하는 것
# 가장 기본적이고 중요한 알고리즘으로 오름차순과 내림차순이 있다.

# 용어정리
# 레코드 : 정렬시켜야 될 대상으로 여러개의 필드로 이루져있다.
# 정렬 키 : 정렬의 기준이 되는 필드
# 정렬 : 레코드들을 키의 순서로 재배열하는 것

# 정렬 장소에 따른 분류(데이터의 크기가 크면 메모리에 넣기 힘들다.)
# 내부정렬 : 모든 데이터가 메인 메모리
# 외부정렬 : 외부 기억 장치에 대부분의 레코드

# 단순하지만 비효율적인 방법
# 삽입, 선택, 버블 정렬 등

# 복잡하지만 효율적인 방법
# 퀵, 힙, 병합, 기수 정렬, 팀 등

# 정렬 알고리즘의 안전성(stability) 
# 동일한 값을 가진 데이터를 정렬할때 두 데이터의 위치가 바뀌면 안정성을 충족하지 않는다.

# 간단한 정렬 알고리즘

# 선택 정렬
# 오른쪽 리스트에서 가장 작은 숫자(최솟값)를 선택하여 왼쪽 리스트의 맨 뒤로 이동하는 작업을 반복

# 시간 복잡도 : O(n^2) -> for문이 두번 돌아가므로  

def selection_sort(A) : # 반복을 진행하며 가장 작은 값을 왼쪽으로 배치한다.
    n = len(A)
    for i in range(n-1): # 0부터 -2까지의 인덱스 차례로 선택
        least = i; # key값 입력
        for j in range(i+1, n): # i보다 큰 인덱스를 차례로 선택
            if(A[j] < A[least]): # j값이 나타내는 값이 더 작으면 
                least = j # j값을 저장
        A[i], A[least] = A[least], A[i] # 가장작은 값은 나타내는 인덱스와 시작 인덱스를 이용하여 값 스왑
        printStep(A, i+1); # 출력문 선언
        
def printStep(arr, val):
    print("   step %2d = " % (val), end='')
    print(arr)
        
if __name__ == "__main__":
    data = [5, 3, 8, 4, 9, 1, 6, 2, 7]
    print("Original :  ", data)
    selection_sort(data)
    print("Selection : ", data)        
    
# 출력
# Original :   [5, 3, 8, 4, 9, 1, 6, 2, 7]
#    step  1 = [3, 5, 8, 4, 9, 1, 6, 2, 7]
#    step  2 = [3, 5, 8, 4, 9, 1, 6, 2, 7]
#    step  3 = [3, 4, 5, 8, 9, 1, 6, 2, 7]
#    step  4 = [3, 4, 5, 8, 9, 1, 6, 2, 7]
#    step  5 = [1, 3, 4, 5, 8, 9, 6, 2, 7]
#    step  6 = [1, 3, 4, 5, 6, 8, 9, 2, 7]
#    step  7 = [1, 2, 3, 4, 5, 6, 8, 9, 7]
#    step  8 = [1, 2, 3, 4, 5, 6, 7, 8, 9]
# Selection :  [1, 2, 3, 4, 5, 6, 7, 8, 9]


