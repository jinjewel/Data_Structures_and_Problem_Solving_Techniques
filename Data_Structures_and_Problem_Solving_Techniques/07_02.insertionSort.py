#######################################
# 정보통계학과 
# 학번 : 2019015020 
# 이름 : 오진석
# 작성일 : 10.26
#######################################

# 삽입 정렬
# 정렬되어 있는 부분에 새로운 레코드를 올바른 위치에 삽입하는 과정

# 복잡도 분석 : O(n^2) -> 역순으로 정렬되어 있는 경우

# 특징 
# 많은 이동 필요 - >  레코드가 큰 경우 불리
# 안정된 정렬방법
# 대부분 정렬되어 있으면 매우 효율

# 알고리즘
# i=1 key=3 j= 0 T 5 3 8 4 9 1(변환 전)
#                  5 5 8 4 9 1(변환 후) 
#           j=-1 F 5 5 8 4 9 1(변환 전)
#                  3 5 8 4 9 1(변환 후) key값 대입   
# i=2 key=8 j= 1 F 3 5 8 4 9 1(변환 전)
#                  3 5 8 4 9 1(변환 후) key값 대입  
# i=3 key=4 j= 2 T 3 5 8 4 9 1(변환 전)
#                  3 5 8 8 9 1(변환 후) 
#           j= 1 T 3 5 8 8 9 1(변환 전)
#                  3 5 5 8 9 1(변환 후) 
#           j= 0 T 3 5 5 8 9 1(변환 전)
#                  3 4 5 8 9 1(변환 후) key값 대입  
# i=4 key=9 j= 3 F 3 4 5 8 9 1(변환 전)
#                  3 4 5 8 9 1(변환 후) key값 대입 
# i=5 key=1 j= 4 T 3 4 5 8 9 1(변환 전)
#                  3 4 5 8 9 9(변환 후) 
#           j= 3 T 3 4 5 8 9 9(변환 전)
#                  3 4 5 8 8 9(변환 후)
#           j= 2 T 3 4 5 8 8 9(변환 전)
#                  3 4 5 5 8 9(변환 후)
#           j= 1 T 3 4 5 5 8 9(변환 전)
#                  3 4 4 5 8 9(변환 후)
#           j= 0 T 3 4 4 5 8 9(변환 전)
#                  3 3 4 5 8 9(변환 후)
#           j=-1 F 3 3 4 5 8 9(변환 전)
#                  1 3 4 5 8 9(변환 후) key값 대입
def insertion_sort(A):
    n = len(A)
    for i in range(1, n):
        key = A[i]
        j = i-
        # j >= 0 : 인덱스는 0이상 이므로 음수가 되면 반복을 중단한다.
        # A[j] > key : 인덱스를 줄이면서 key값과 비교, key값보다 값이 크면 반복
        while j >= 0 and A[j] > key :
            A[j+1] = A[j] # 
            j -= 1
        A[j+1] = key # 비교하는 key값보다 작은 값이 나오면 그 인덱스 바로 오른쪽에 삽입
        printStep(A, i)

def printStep(arr, val):
    print("   step %2d = " % (val), end='')
    print(arr)

if __name__ == "__main__":
    data = [5, 3, 8, 4, 9, 1, 6, 2, 7]
    print("Original :  ", data)
    insertion_sort(data)
    print("Selection : ", data)          

# 출력
# Original :  [5, 3, 8, 4, 9, 1, 6, 2, 7]
#    step  1 = [3, 5, 8, 4, 9, 1, 6, 2, 7]
#    step  2 = [3, 5, 8, 4, 9, 1, 6, 2, 7]
#    step  3 = [3, 4, 5, 8, 9, 1, 6, 2, 7]
#    step  4 = [3, 4, 5, 8, 9, 1, 6, 2, 7]
#    step  5 = [1, 3, 4, 5, 8, 9, 6, 2, 7]
#    step  6 = [1, 3, 4, 5, 6, 8, 9, 2, 7]
#    step  7 = [1, 2, 3, 4, 5, 6, 8, 9, 7]
#    step  8 = [1, 2, 3, 4, 5, 6, 7, 8, 9]
# Selection :  [1, 2, 3, 4, 5, 6, 7, 8, 9]








