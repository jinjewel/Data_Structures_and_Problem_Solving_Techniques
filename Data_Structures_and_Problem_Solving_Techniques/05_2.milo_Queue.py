#######################################
# 정보통계학과 
# 학번 : 2019015020 
# 이름 : 오진석
# 작성일 : 10.12
#######################################

# 큐의 응용 : 너비우선탐색

# 미로탐색 : 너비우선탐색

# 큐를 이용한 미로 탐색 코드
from CircularQuenue import CircularQueue

def isValidPos(x, y): # 지금의 좌표가 유의한지 검사하는 함수
    if x<0 or y<0 or x >= MAZE_SIZE or y >= MAZE_SIZE: # 범위 밖이면 False
        return False
    else:
        return map[y][x] == '0' or map[y][x] == 'x' # 0, x만 참, 1은 거짓

def BFS(): # 너비 우선 탐색 함수
    que = CircularQueue() # 원형큐(리스트) 생성
    que.enqueue((0,1)) # 시작위치 삽입, (0,1)은 튜플
    print('BFS: ')
    
    while not que.isEmpty(): # 비어있지 않으면
        here = que.dequeue() # 맨위에 좌표 대입 후 삭제
        x, y = here # 맨 위에 있던 좌표를 각각 대입
        print(here, end="->")
        # 켬퓨터는 입력한 값이 열 중심으로 입력되기 때문에 y=-x 대칭으로 인식하여 
        # map[x][y]가 아닌 map[y][x]로 해야 우리가 보는 모습과 같게 위치시킬수 있다.
        if (map[y][x] == 'x'): # 출구면 탐색 성공, T반환
            return True
        else:
            map[y][x] = '.' # 현재 위치를 지나왔다고 '.'표시, 그래야 isValidPos에서 범위 밖으로 판단하여 역주행을 안한다.
            # 컴터는 열을 기준으로 값을 대입하므로 눈에 보이는 지도와 인댁스가 y=-x 대칭이다.
            # 따라서 [x][y] 가 아닌 [y][x]로 생성
            # 4방향의 이웃을 검사해 갈 수 있으면 스택에 상하좌우를 우선순위로 삽입
            if isValidPos(x, y-1): # 움직인 점이 T이면(0 또는 x) 실행
               que.enqueue((x, y-1)) # 상, 만약 [x][y]이였다면, (x-1, y)
            if isValidPos(x, y+1): # 움직인 점이 T이면(0 또는 x) 실행
               que.enqueue((x, y+1)) # 하, 만약 [x][y]이였다면, (x+1, y)                
            if isValidPos(x-1, y): # 움직인 점이 T이면(0 또는 x) 실행
               que.enqueue((x-1, y)) # 좌, 만약 [x][y]이였다면, (x, y-1)               
            if isValidPos(x+1, y): # 움직인 점이 T이면(0 또는 x) 실행
               que.enqueue((x+1, y)) # 우, 만약 [x][y]이였다면, (x, y+1)         
    return False               

# 본문
if __name__ == "__main__":
    
    MAZE_SIZE = 6 # 정사각형의 미로의 사이즈 지정
    # 실제로 컴터가 인식하는 방향은 y=-x 대칭 모양이므로 x,y의 순서를 바꿔서 행렬을 계산한다.
    map = [['1', '1', '1', '1', '1', '1'], 
           ['e', '0', '1', '0', '0', '1'], 
           ['1', '0', '0', '0', '1', '1'], 
           ['1', '0', '1', '0', '1', '1'], 
           ['1', '0', '1', '0', '0', 'x'],
           ['1', '1', '1', '1', '1', '1'] ] 
    
    result = BFS() # 결과 입력
    print('--> 미로탐색 성공') if result else print('--> 미로탐색 실패')
    # # 결과 출력
    # if result:
    #     print('--> 미로탐색 성공')
    # else:
    #     print('--> 미로탐색 실패')

'''
(0, 1)->(1, 1)->(1, 2)->(1, 3)->(2, 2)->(1, 4)->(3, 2)->(3, 1)->
(3, 3)->(4, 1)->(3, 4)->(4, 4)->(5, 4)->--> 미로탐색 성공
'''



