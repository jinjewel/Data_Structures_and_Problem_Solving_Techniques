#######################################
# 정보통계학과 
# 학번 : 2019015020 
# 이름 : 오진석
# 작성일 : 09.14
#######################################

# 프로그램 = 자료구조 + 알고리즘

# 자료구조 : 컴퓨터에서 자료를 정리하고 조직화하는 다양한 구조
# 선형자료구조 : 항목들을 순서적으로 나열하여 저장하는 창고 : 리스트, 스택, 큐, 덱 등
# 비선형자료구조 : 항목들이 보다 복잡한 연결관계 : 트리, 그래프

# 알고리즘 : 컴퓨터로 문제를 풀기 위한 단계적 절차
# 알고리즘의 조건 
# 입력 : 0개 이상의 입력이 존재
# 출력 : 1개 이상의 출력이 존재해야한다.
# 명백성 : 각 명령어의의미는 모호하지 않고 명백해야 한다.
# 유한성 : 한정된 수의 단계 후에는 반드시 종료되어야 한다.
# 유효성 : 각 명령어들은 실행 가능한 연산이어야 한다.

# 알고리즘의 기술 방법
# 자연어 : 읽기 쉽지만 단어들을 정확하게 정의하지 않으면 의미가 모호하다.
# 흐름도 : 직관적이며 이해하기 쉽다. 하지만 엄청나게 복잡한 알고리즘을 가지고 있다.
# 유사코드 : 알고리즘의 핵심적인 내용에만 집중가능하다.
# 특정언어 : 알고리즘의 가장 정확한 기술 가능, 단 구현시의 사항들이 알고리즘의 핵심적인 내용들의 이해를 방해

# 추상자료형(ADT) : 프로그래머가 추상적으로 정의한 자료형, 시스템의 정말 핵심적인 구조나 동작에만 집중
# 데이터 타입을 추상적(수학적)으로 정의한 것, 무엇인가를 정의하지만 어떻게 구현할 것인가는 정의하지 않음.

# 예) bag의 추상 자료형(ADT)
# Bag : 비어있는 가방을 새로 만든다.
# insert(e) : 가방에 항목 e를 넣는다.
# remove(e) : 가방에 e가 있는지 검사하여 있으면 이 항목을 꺼낸다.
# contains(e) : e가 들어있으면 T, 없으면 F를 반환한다.
# count() : 가방에 들어있는 항목들의 수를 반환한다.

# 예) bag의 추상 자료형의 구현(파이썬 사용)
def contains(bag, e):
    return e in bag
    
def insert(bag, e):
    bag.append(e)
    
def remove(bag, e):
    bag.remove(e) 
    
def count(bag):
    return len(bag)    

## 알고리즘의 성능분석 기법

## 실행 시간을 측정하는 방법 : 두 개의 알고리즘의 실제 실행 시간을 측정하는 것이며, 실제로 구현하는 것이 필요
# time모듈을 사용하여 직접 실행

## 알고리즘의 복잡도를 분석하는 방법 : 직접 구현하지 않고서도 수행 시간을 분석하는 것, 일반적으로 연산의 횟수는 n이다.
# 시간 복잡도 분석 : 수행 시간 분석
# 기본적인 연산 고려, 알고리즘 수행에 필요한 연산의 개수를 계산, 시간 복잡도 함수 T(n)

# 공간 복잡도 분석 : 수행 시 필요로 하는 메모리 공간 분석

# 빅오표기법
# 차수가 가장 큰 항이 절대적인 영향
# 다른 항들은 상대적으로 무시
# f(n)=5 -> O(1) : 상수형
# f(n)=2n+1 -> O(n) : 선형
# f(n)=3n*n+100 -> O(n*n) : 2차형
# f(n)=5*2^n + n*n + 100 -> O(2^n) : 지수형

# 실행시간은 입력 집합에 따라 다를수 있다.
# 빅오메가 - 최선의 경우 : 수행 시간이 가장 빠른 경우, 의미가 없는 경우가 많다.
# 빅세타 - 평균의 경우 : 수행시간이 평균적인 경우, 계산하기가 상당히 어려움
# 빅오 - 최악의 경우 : 수행시간이 가장 늦은 경우, 가장 널리 사용되고, 계산하기 쉽고, 응용에 따라 중요한 의미를 가짐

# 순환과 반복의 알고리즘
# 순환 - O(log2n) : 순환적인 문제에서는 자연스러운 방법, 대부분의 순환은 반복으로 바꾸어 작성할 수 있음
# 반복 - O(n): 수행속도가 빠름    

# 예) 거듭제곱 : 순환이 빠른 예시
# 순환 - O(log2n) 
# 반복 - O(n)

# 예) 피보나치 수열 : 순환이 느린 예시
# 순환 - O(2^n) 
# 반복 - O(n)

# 하노이의 탑 - 순환을 이용
def Hanoi_tower(n, fr, tmp, to): # 하노이의 탑 순환 함수
    
    if (n==1): # 종료 조건
        print("원판 1: %s --> %s" % (fr, to)) # 가장작은 원판을 옮김
    else:
        Hanoi_tower(n-1, fr, to, tmp) # n-1개를 to를 이용해 tmp로
        print("원판 %d: %s --> %s" % (n, fr, to)) # 하나의 원판을 옮김
        Hanoi_tower(n-1, tmp, fr, to)  # n-1개를 fr를 이용해 to로

if __name__ == "__main__":
    
    # 예) bag의 추상 자료형의 구현(파이썬 사용)
    myBag = []
    insert(myBag, '휴대폰')
    insert(myBag, '지갑')
    insert(myBag, '손수건')
    insert(myBag, '빗')
    insert(myBag, '자료구조')
    insert(myBag, '야구공')
    print('가방속의 물건', myBag)
    
    insert(myBag, '빗') # 중복이라도 입력
    remove(myBag, '손수건') # 손수건 제거
    print('가방속의 물건', myBag)
    
    # 하노이의 탑 - 순환을 이용
    print("\n\n하노이의 탑")
    Hanoi_tower(4, 'A', 'B', 'C')
       
'''
가방속의 물건 ['휴대폰', '지갑', '손수건', '빗', '자료구조', '야구공']
가방속의 물건 ['휴대폰', '지갑', '빗', '자료구조', '야구공', '빗']


하노이의 탑
원판 1: A --> B
원판 2: A --> C
원판 1: B --> C
원판 3: A --> B
원판 1: C --> A
원판 2: C --> B
원판 1: A --> B
원판 4: A --> C
원판 1: B --> C
원판 2: B --> A
원판 1: C --> A
원판 3: B --> C
원판 1: A --> B
원판 2: A --> C
원판 1: B --> C
'''
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    