#######################################
# 정보통계학과 
# 학번 : 2019015020 
# 이름 : 오진석
# 작성일 : 11.30
#######################################

# 최단경로 알고리즘이란
# 정점 U와 정점 V를 연결하는 경로 중에서 간선들의 가중치 합이 최소가 되는 경로
# 간선의 가중치는 비용, 거리, 시간 등이 있다.
# 알고리즘으로 Dijkstra와 Floyd 알고리즘이 있다.

# Floyd의 최단경로 알고리즘
# 모든 정점 사이의 최단경로를 찾는다.
# 2차원 배열 A를 이용하여 3중 반복을 하는 루프로 구성 
# 배열 A의 초기 값은 인접 행렬의 가중치

# A[i][j]^k : 0~k까지의 정점만을 이용한 정점i에서 j까지의 최단 경로 길이
# A^-1 -> A^0 -> A^1 -> ... -> A^n-1 순으로 최단경로 길이를 구함

# Dijkstra : O(n^2)
# 주 반복문을 n번 반복
# 내부 반복문을 2n번 반복
# 모든 정점 쌍의 최단 경로를 구한려면 n번 반복 -> O(n^3)

# Floyd-Warshall : O(n^3)
# 모든 정점 쌍의 최단 경로 거리를 구함
# 3중 반복문을 실행 
# Floyd의 알고리즘은 매우 간결한 반복 구문을 사용

def shortest_path_floyd(vertex, adj):
    vsize = len(vertex) # 정점의 개수
    A = list(adj) # 두의: 2차원 배열(리스트의 리스트)의 복사
    for i in range(vsize): # 각각의 열에 대해
        A[i] = list(adj[i]) # 열(리스트)을 복사
        
    for k in range(vsize): # 정점 k를 추가할 때
        for i in range(vsize): 
            for j in range(vsize): # 모든 A[i][j]
                if (A[i][k] + A[k][j] < A[i][j]):
                    A[i][j] = A[i][k] + A[k][j]
        print("===============================") # 변경한 배열 출력
        for x in range(vsize):
            for y in range(vsize):
                print("%3d"%A[x][y], end=' ')
            print()
            
            
if __name__ == "__main__":
    INF = 999
    
    vertex = ['A', 'B', 'C', 'D', 'E', 'F', 'G']
    # 이차원 배열에 인접 행렬을 표시
    weight = [[0, 7, INF, INF, 3, 10, INF],
              [7, 0, 4, 10, 2, 6, INF],
              [INF, 4, 0, 2, INF, INF, INF],
              [INF, 10, 2, 0, 11, 9, 4],
              [3, 2, INF, 11, 0, INF, 5],
              [10, 6, INF, 9, INF, 0, INF],
              [INF, INF, INF, 4, 5, INF, 0]] 
    
    # Dijkstra 알고리즘의 결과와 동일 
    print("Shortest Path By Floyd's Algorithm")
    path = shortest_path_floyd(vertex, weight)
    
# 출력
# Shortest Path By Floyd's Algorithm
# ===============================
#   0   7 999 999   3  10 999 
#   7   0   4  10   2   6 999 
# 999   4   0   2 999 999 999 
# 999  10   2   0  11   9   4 
#   3   2 999  11   0  13   5 
#  10   6 999   9  13   0 999 
# 999 999 999   4   5 999   0 
# ===============================
#   0   7  11  17   3  10 999 
#   7   0   4  10   2   6 999 
#  11   4   0   2   6  10 999 
#  17  10   2   0  11   9   4 
#   3   2   6  11   0   8   5 
#  10   6  10   9   8   0 999 
# 999 999 999   4   5 999   0 
# ===============================
#   0   7  11  13   3  10 999 
#   7   0   4   6   2   6 999 
#  11   4   0   2   6  10 999 
#  13   6   2   0   8   9   4 
#   3   2   6   8   0   8   5 
#  10   6  10   9   8   0 999 
# 999 999 999   4   5 999   0 
# ===============================
#   0   7  11  13   3  10  17 
#   7   0   4   6   2   6  10 
#  11   4   0   2   6  10   6 
#  13   6   2   0   8   9   4 
#   3   2   6   8   0   8   5 
#  10   6  10   9   8   0  13 
#  17  10   6   4   5  13   0 
# ===============================
#   0   5   9  11   3  10   8 
#   5   0   4   6   2   6   7 
#   9   4   0   2   6  10   6 
#  11   6   2   0   8   9   4 
#   3   2   6   8   0   8   5 
#  10   6  10   9   8   0  13 
#   8   7   6   4   5  13   0 
# ===============================
#   0   5   9  11   3  10   8 
#   5   0   4   6   2   6   7 
#   9   4   0   2   6  10   6 
#  11   6   2   0   8   9   4 
#   3   2   6   8   0   8   5 
#  10   6  10   9   8   0  13 
#   8   7   6   4   5  13   0 
# ===============================
#   0   5   9  11   3  10   8 
#   5   0   4   6   2   6   7 
#   9   4   0   2   6  10   6 
#  11   6   2   0   8   9   4 
#   3   2   6   8   0   8   5 
#  10   6  10   9   8   0  13 
#   8   7   6   4   5  13   0 


